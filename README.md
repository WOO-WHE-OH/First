# top 명령어
실시간 프로세스를 출력해주는 명령어입니다.
1. -n옵션을 붙이면 => 지정한 숫자만큼 화면 출력을 갱신합니다.
2. -u옵션을 붙이면 => 지정한 사용자의 프로세스를 모니터링합니다.
3. -b옵션을 붙이면 => 출력결과를 파일이나 다른 프로그램으로 전달합니다.
4. -d옵션을 붙이면 => 화면갱신주기를 초 단위로 설정합니다.
5. -p옵션을 붙이면 => 지정한 PID 프로세스를 모니터링합니다.

이 명령어를 입력하게 되면 첫번째줄부터 다섯번째줄까지는 시스템 요약 부분이고 그 다음줄부터는 프로세스 cpu 사용 순서 부분입니다.

<시스템 요약 부분>
+ 첫번째줄: 현재시간, 서버가동 후 유지시간, 현재 접속 사용자, 최근 1, 5, 15분 동안 시스템 부하를 보여줍니다.
+ 두번째줄: 프로세스의 상태(총 프로세스, 실행 중, sleep, stop, 좀비프로세스)를 보여줍니다.
+ 세번째줄: cpu상태를 보여줍니다.
+ 네번째줄: memory상태를 보여줍니다.
+ 다섯번째줄: swap메모리 상태를 보여줍니다.

<프로세스 cpu 사용 순서 부분>
+ PR: 우선순위를 보여줍니다.
+ NI: Nice value(-20 ~ 19사이의 숫자이며 값이 작을수록 우선순위가 높음)를 보여줍니다.
+ VIRT: 작업에 사용된 가상 메모리 총사용량을 보여줍니다.
+ RES: 프로세스가 사용하는 실제 메모리양을 보여줍니다.
+ SHR: 프로세스가 사용하는 공유 메모리양을 보여줍니다.
+ S: 현재 프로세스의 상태를 보여줍니다.
+ TIME+: 프로세스가 시작하여 사용한 cpu시간을 보여줍니다.

추가적으로 top을 통해 모니터링 중인 상태에서 h를 누르면 다양한 추가적인 기능들에 대한 도움말을 볼 수가 있습니다. 또 하나는 최근에는 사용자에게 조금 더 친화적인 htop이라는 명령어를 사용하기도 합니다.

이제 이 다음으로 설명할 ps명령어랑 비교해보면 ps명령어는 명령어가 실행된 순간의 프로세스 상태들에 대해서 정적인 정보만을 제공해주는 것이고 지금 설명하고 있는 top명령어는 시스템 활동을 실시간으로 확인할 수 있다는 차이가 있습니다.

# ps 명령어
프로세스를 출력해주는 명령어입니다.

<기본 프로세스 출력>
1. a옵션을 붙이면 => 터미널과 연관된 프로세스만 출력합니다.
2. x옵션을 붙이면 => 터미널과 연관되지 않는 프로세스만 출력합니다.
3. -A옵션을 붙이면 => 모든 프로세스를 출력합니다. (-e와 같습니다.)
4. -e옵션을 붙이면 => 모든 프로세스를 출력합니다. (-A와 같습니다.)
5. -a옵션을 붙이면 => 세션 리더와 터미널과 연관되지 않은 프로세스를 제외하고 모든 프로세스를 출력합니다.

<지정한 프로세스 출력>
1. P옵션을 붙이면 => 지정한 PID 목록의 정보만 출력합니다.
2. -C옵션을 붙이면 => 지정한 프로세스의 실행 파일 이름의 정보만 출력합니다.
3. -u옵션을 붙이면 => 특정 사용자의 프로세스 정보를 출력합니다.

<프로세스 표시 형식>
1. u옵션을 붙이면 => 프로세스의 소유자 정보를 함께 출력합니다.
2. l옵션을 붙이면 => BSD형식의 긴 형식으로 출력합니다.
3. e옵션을 붙이면 => 프로세스 정보와 함께 프로세스의 환경변수 정보도 출력합니다.
4. -l옵션을 붙이면 => 긴 포맷으로 출력합니다.
5. -o옵션을 붙이면 => 사용자 정의 형식 지정이 가능합니다.

<프로세스 장식>
1. f옵션을 붙이면 => 프로세스 계층을 텍스트 형식의 트리구조로 보여줍니다.
2. -f옵션을 붙이면 => 전체 포맷으로 출력합니다.

다음으로 ps 프로세스 도표 항목이 무엇인지 보겠습니다.

<프로세스 항목>
+ F: 프로세스 플래그를 보여줍니다.
+ S: 프로세스 상태코드를 보여줍니다.
+ UID: 프로세스 소유자 이름을 보여줍니다.
+ PID: 프로세스 고유 식별자를 보여줍니다.
+ PPID: 부모 프로세스의 PID를 보여줍니다.
+ C: 프로세서 사용률을 %로 보여줍니다.
+ PRI: 프로세스의 우선순위를 보여줍니다.
+ NI: nice값이며 19 ~ -20값을 나타냅니다.
+ SZ: 프로세스 이미지가 차지하는 물리적 페이지 크기를 나타냅니다.
+ WCHAN: 대기 중일때 커널 함수의 이름을 나타냅니다.
+ STIME: 프로세스가 시작한 시간을 보여줍니다.
+ TTY: 터미널의 종류를 보여줍니다.
+ TIME: 총 cpu 사용시간을 보여줍니다.
+ CMD: 프로세스 실행 시 명령줄을 나타냅니다.

# jobs 명령어
백그라운드 프로세스를 출력해주는 명령어입니다.

이 명령어는 현재 돌아가고 있는 백그라운드 프로세스 리스트를 모두 출력해주고, 백그라운드 프로세스는 스택처럼 쌓이는데 

+ +는 스택의 가장 위에 있다는 것입니다.
+ -는 바로 그 다음 밑에 있다는 것입니다.

# kill 명령어
프로세스를 제어하는 명령어입니다.

시그널이라는 것은 프로세스 사이의 통신 수단인데 어떤 프로세스에 메시지를 보내 프로세스를 제어하게 되고 명령어를 실행함으로써 프로세스가 시작되고 그 프로세스를 제어하기 위하여 사전에 정의된 시그널이 존재합니다.

1. -l옵션을 붙이면 => 시그널의 종류를 출력합니다.
2. -s옵션을 붙이면 => 시그널의 이름을 지정해줍니다.
3. -v옵션을 붙이면 => 시그널 전송 결과를 출력합니다.
4. -w옵션을 붙이면 => 시그널을 받은 프로세스들이 종료 될때까지 대기합니다.

<사전에 정의된 시그널> kill -l
+ 번호 1번 => SIGHUP: 터미널에서 접속이 끊겼을 때 보내지는 시그널이고 변화된 내용을 적용하기 위해 재시작할 때 사용됩니다.
+ 번호 2번 => SIGINT: 인터럽트 시그널로 실행을 중지시키고 Ctrl + c 입력 시 보내지는 시그널입니다.
+ 번호 3번 => SIGQUIT: 실행 중지 시그널이고 Ctrl + \ 입력 시 보내지는 시그널입니다.
+ 번호 9번 => SIGKILL: 프로세스를 강제로 종료시키는 시그널입니다.
+ 번호 15번 => SIGTERM: kill의 기본 시그널로 정상 종료 시키는 시그널입니다.
+ 번호 18번 => SIGCONT: 시그널에 의해 정지된 프로세스를 다시 실행시키는 시그널입니다.
+ 번호 19번 => SIGSTOP: 정지 시그널입니다.
+ 번호 20번 => SIGTSTP: 일시정지 시키는 시그널로서 Ctrl + z 입력 시 보내지는 시그널입니다.

위의 경우처럼 몇 가지 시그널이 존재하는데 불필요한 프로세스나 잘못 실행된 프로세스를 죽이는데 사용할 것은 프로세스를 강제로 종료시키는 명령어인 kill을 사용합니다. 이 명령어를 사용하면 좀비 프로세스나 응답 없음이나 비정상적으로 동작하는 프로세스들의 실행을 끝내줍니다.

추가적으로 프로세스 여러개를 종료해주는 명령어인 killall인 명령어도 있습니다.
